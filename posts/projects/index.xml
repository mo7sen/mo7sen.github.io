<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - Robear Selwans' Portfolio</title><link>https://mo7sen.github.io/posts/projects/</link><description>All Posts | Robear Selwans' Portfolio</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>robear.selwans@outlook.com (Robear Selwans)</managingEditor><webMaster>robear.selwans@outlook.com (Robear Selwans)</webMaster><lastBuildDate>Sat, 31 Jul 2021 13:25:24 +0000</lastBuildDate><atom:link href="https://mo7sen.github.io/posts/projects/" rel="self" type="application/rss+xml"/><item><title>CPU RayTracer</title><link>https://mo7sen.github.io/projects/cpu-raytracer/</link><pubDate>Sat, 31 Jul 2021 13:25:24 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/cpu-raytracer/</guid><description>Introduction After finishing my first raytracer, it was obvious that I needed to make another one if I wanted to learn more about the topic. However, since I wasn’t confident enough to step out of the tutorial territory, I decided that I would use Peter Shirley’s RTOW series.
One of the major advantages of this series is that while it is introducing the concepts in a gentle manner, it is also giving advice on how to structure the project so that adding more features in the future doesn’t end up being a huge task with tons of refactors.</description></item><item><title>ImprovGFX</title><link>https://mo7sen.github.io/projects/improvgfx/</link><pubDate>Sat, 31 Jul 2021 13:25:24 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/improvgfx/</guid><description>Introduction For the “Computer Graphics” course, it was announced from the beginning of the course that the final project will be a scene rendered using OpenGL or WebGL. However, for someone like me who’s been introduced to what graphics programming is (with no actual experience), I thought it would be way cooler to build my own offline renderer. The only reason I was confident enough to ask the professor if I could make this project instead is because of ssloy’s tiny-renderer tutorial series.</description></item><item><title>RusTracer</title><link>https://mo7sen.github.io/projects/rustracer/</link><pubDate>Sat, 31 Jul 2021 13:25:24 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/rustracer/</guid><description>In an effort to learn about ray tracing, I decided to follow ssloy’s tinyraytracer tutorial which is, in my opinion, a very gentle introduction into the world of raytracing. Despite the tutorial using C++, I decided to use Rust for no reason except that I hadn’t written any Rust code in a while and felt a bit rusty (pun intended).
Another thing that I did differently from the tutorial is that I rendered to an SDL window instead of rendering to an image.</description></item><item><title>RustyNinja</title><link>https://mo7sen.github.io/projects/rustyninja/</link><pubDate>Sat, 31 Jul 2021 13:25:24 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/rustyninja/</guid><description>It started with me finding out that RDJ2019 (Game showcase event) was around the corner and deciding that I wanted to submit an entry for a game that I’d like to play. So I started thinking about a game idea until I remembered this clip. I liked the idea of a ninja jumping on missiles while simultaneously destroying them, and that’s what I decided to make.
So the idea was as follows: you’re a ninja in a peaceful village, an army is attacking the village to get rid of its residents and control its resources, you start attacking the missiles that are shot at the village to make sure that none of them reach their target.</description></item><item><title>evol</title><link>https://mo7sen.github.io/projects/evol/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol/</guid><description>&lt;p>A game engine built using C.&lt;/p></description></item><item><title>evol Architecture</title><link>https://mo7sen.github.io/projects/evol-architecture/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol-architecture/</guid><description>Overview Any software that is being designed needs to adhere to a specific architecture. Having an explicit architecture allows the design process to be much smoother as architectures come with their own set of rules that can increase consistency across the entire software. A game engine is no different; in fact, as the game engine is a much bigger software than most, it sometimes needs to have multiple architectures with some subsystems having their own ones.</description></item><item><title>evol-assetmanager</title><link>https://mo7sen.github.io/projects/evol-assetmanager/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol-assetmanager/</guid><description>The asset managers try to provide some features that make the workflow of adding/using assets less painful. While there is no fancy features like asynchronous loading or callbacks, the base foundation of the asset manager is quite flexible and allows the addition of such features in the future.
Mounts Ok, so it&amp;rsquo;s probably not the best idea to start this off with a QoL feature, but it&amp;rsquo;s too fun to leave for later.</description></item><item><title>evol-core</title><link>https://mo7sen.github.io/projects/evol-core/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol-core/</guid><description>First of all, comes the core. The core was implemented in a way that ensures that all core functionalities are provided to the modules without the need for complex dependencies. The first thing that needed to be done was to make the modules loadable/unloadable at runtime. While multiple approaches were tried out at the beginning, the most stable one was the use of dynamically loaded libraries (DLLs). The main advantage of using DLLs is the fact that the load/unload operation is handled primarily by the operating system.</description></item><item><title>evol-game</title><link>https://mo7sen.github.io/projects/evol-game/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol-game/</guid><description>The game module is where most of the fun actually happens; the game module attempts to use the other modules to make the program behave as a game engine. Through the combination of the world module, the input module, the physics module, the script module, the asset module and the rendering module, the game module manages to connect all these modules together to make an actual game that runs.
First of all is the scene representation; in the game module, a scene is an isolated component that cannot interact with other scenes.</description></item><item><title>evol-renderer</title><link>https://mo7sen.github.io/projects/evol-renderer/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol-renderer/</guid><description>Introduction The rendering module is one of the more special modules; this is mainly because dependencies were kept to a minimum and extra effort was put to ensure that most of the module was actually built from scratch.
Implementation For the graphics API, we used Vulkan. This decision was quite easy to take actually as DirectX wasn’t natively supported in linux and OpenGL wouldn’t provide any experience when it comes to newer graphics APIs which are way more verbose and provide more control over almost everything.</description></item></channel></rss>