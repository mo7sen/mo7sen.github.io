<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<title>evol-core - Robear Selwans' Portfolio</title><meta name=description content="The core of the evol framework used to build the evol game engine."><meta property="og:title" content="evol-core">
<meta property="og:description" content="The core of the evol framework used to build the evol game engine.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://mo7sen.github.io/projects/evol/modules/core/"><meta property="article:section" content="projects">
<meta property="article:published_time" content="2021-07-31T13:25:00+00:00">
<meta property="article:modified_time" content="2021-07-31T13:25:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="evol-core">
<meta name=twitter:description content="The core of the evol framework used to build the evol game engine.">
<meta name=application-name content="Robear Selwans' Portfolio">
<meta name=apple-mobile-web-app-title content="Robear Selwans' Portfolio"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://mo7sen.github.io/projects/evol/modules/core/><link rel=prev href=https://mo7sen.github.io/projects/evol/modules/physics/><link rel=next href=https://mo7sen.github.io/projects/evol/modules/asset-manager/><link rel=stylesheet href=/css/page.min.css><link rel=stylesheet href=/css/home.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"evol-core","inLanguage":"en-us","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/mo7sen.github.io\/projects\/evol\/modules\/core\/"},"genre":"projects","keywords":"Game Engine","wordcount":3835,"url":"https:\/\/mo7sen.github.io\/projects\/evol\/modules\/core\/","datePublished":"2021-07-31T13:25:00+00:00","dateModified":"2021-07-31T13:25:00+00:00","publisher":{"@type":"Organization","name":"Robear Selwans"},"author":{"@type":"Person","name":"Robear Selwans"},"description":"The core of the evol framework used to build the evol game engine."}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="Robear Selwans' Portfolio">Robear Selwans' Portfolio</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/about/> About </a><a class=menu-item href=/categories/project/> Projects </a><a class=menu-item href=/categories/post/> Posts </a><a class=menu-item href=/categories/> Categories </a><a class=menu-item href=/tags/> Tags </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a>
</div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="Robear Selwans' Portfolio">Robear Selwans' Portfolio</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><a class=menu-item href=/about/ title>About</a><a class=menu-item href=/categories/project/ title>Projects</a><a class=menu-item href=/categories/post/ title>Posts</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=/tags/ title>Tags</a><div class=menu-item><a href=javascript:void(0); class=theme-switch title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a>
</div></div>
</div>
</header><main class=main>
<div class=container><div class=toc id=toc-auto style=top:8rem>
<h2 class=toc-title>Contents</h2>
<div class=toc-content id=toc-content-auto></div>
</div><article class="page single special" data-toc=disable><h2 class="single-title animated fadeInDown faster">evol-core</h2><div class=single-card><div class="details toc" id=toc-static data-kept>
<div class="details-summary toc-title">
<span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents></nav></div>
</div><div class=content id=content><p>First of all, comes the core. The core was implemented in a way that ensures that all core functionalities are provided to the modules without the need for complex dependencies. The first thing that needed to be done was to make the modules loadable/unloadable at runtime. While multiple approaches were tried out at the beginning, the most stable one was the use of dynamically loaded libraries (DLLs). The main advantage of using DLLs is the fact that the load/unload operation is handled primarily by the operating system. The fact that all modern operating systems implement reference counting for DLLs also made their usage easier as that is one feature that was needed. While DLLs are similarly implemented, each operating system might have its own format to represent it, for example: Microsoft Windows uses (PE) and Linux uses (ELF64). Luckily, each operating system has its own API which exposes a set of functions that are similar in functionality throughout platforms. With that in mind, all that needed to be done was to wrap the OS-specific calls in some platform-agnostic functions that lifted the burden of caring for the operating system off the modules.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ev_module_open</code></td>
<td>Opens module (given its path) and increments its reference count.</td>
</tr>
<tr>
<td><code>ev_module_close</code></td>
<td>Returns handle of a module (given its path) if it is already loaded in memory.</td>
</tr>
<tr>
<td><code>ev_module_gethandle</code></td>
<td>Closes a module (given its handle) and decrements its reference count.</td>
</tr>
<tr>
<td><code>ev_module_getfn</code></td>
<td>Gets a function that is exposed by a module (given the module handle and the name of the function)</td>
</tr>
<tr>
<td><code>ev_module_getvar</code></td>
<td>Gets a variable that is exposed by a module (given the module handle and the name of the variable)</td>
</tr>
</tbody>
</table>
<p>After that, the next step was to provide the modules with a way to run custom behavior whenever they’re loaded or unloaded. To do that, the constructor/destructor functionality was implemented for those modules. Some research was needed to identify the best approach to implement that feature. Luckily, we found that both the ELF64 and PE standards implement ways for the DLLs to run specific functions on load/unload. The ELF64 uses the .init and .fini header sections and PE uses an optional DLLMain function that runs both on initialization and deinitialization. After wrapping these functionalities in our own functions, the following was the minimal format for a module:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// testmod/mod.c
</span><span class=c1></span><span class=n>EV_CONSTRUCTOR</span>
<span class=p>{</span>
  <span class=n>ev_log_info</span><span class=p>(</span><span class=s>&#34;Module Loaded Successfully&#34;</span><span class=p>);</span>
<span class=p>}</span>

<span class=n>EV_DESTRUCTOR</span>
<span class=p>{</span>
  <span class=n>ev_log_info</span><span class=p>(</span><span class=s>&#34;Module Unloaded Successfully&#34;</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>With that layout, the code written in the <code>EV_CONSTRUCTOR</code> is run as soon as a module is initially loaded into memory (its reference count was zero and now it is one) and the <code>EV_DESTRUCTOR</code> is run when no other module needs it anymore (its reference count was just decremented to reach zero).</p>
<p>Before adding more helpful module-managing functionalities, more utility types and features were needed to be added to the core so that it can expose them to the other modules and also use them for the module maintaining process.</p>
<p>Since we’re using C, the first thing that we needed was a generic dynamic array. To do that, we built the <code>vec</code> single-header library. While building this library, there were multiple objectives that we had for it so that its usage was as painless as possible. Those objectives were:</p>
<ul>
<li>Should be usable in the same scenarios that a normal statically-sized array would be used in</li>
<li>Arrays should be indexable in the same way as statically-sized arrays (using square brackets)</li>
<li>Array elements should be allowed to have their own destructors to avoid dangling pointers</li>
<li>Array elements can have their own copy function specified to allow deep copies when needed</li>
</ul>
<p>The first two objectives defined the direction in which the vector structure would go. While a dynamically sized array needs to have a lot of its metadata bundled with it, having the metadata with the vector meant that there would be a distinction between it and the normal arrays. To solve this problem, we decided to store the vector’s metadata right before it. This way, while the parts using the vector will see it as a normal array, the library functions will be aware that a specific length of memory that lies right before that vector are its actual metadata and we’ll be able to retrieve that data easily.</p>
<p>We ended up trying out two approaches:</p>
<ul>
<li>The intuitive one</li>
</ul>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// Intuitive Approach
</span><span class=c1></span><span class=k>struct</span> <span class=p>{</span>
  <span class=n>size_t</span> <span class=n>len</span><span class=p>;</span> <span class=c1>// Length of the vector
</span><span class=c1></span>  <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>;</span> <span class=c1>// Actual data inside the array
</span><span class=c1></span><span class=p>}</span> <span class=n>vec</span><span class=p>;</span>
<span class=c1>// The vector is initialized with the size of the element so that it can be more generic
</span><span class=c1></span><span class=n>vec</span> <span class=n>int_vec</span> <span class=o>=</span> <span class=n>vec_init</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
<span class=kt>int</span> <span class=n>elem</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
<span class=n>vec_push</span><span class=p>(</span><span class=n>int_vec</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>elem</span><span class=p>);</span>
<span class=c1>// The length is directly accessible
</span><span class=c1></span><span class=n>int_vec</span><span class=p>.</span><span class=n>len</span><span class=p>;</span>
<span class=c1>// The vector can&#39;t be indexed directly; the data member is the one that is indexed.
</span><span class=c1></span><span class=p>((</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span><span class=n>int_vec</span><span class=p>.</span><span class=n>data</span><span class=p>)[</span><span class=mi>1</span><span class=p>];</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>The better one</li>
</ul>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// Our (Better) Approach
</span><span class=c1></span><span class=cp>#define vec(T) T*
</span><span class=cp></span><span class=c1>// The use of preprocessor macros allows the use of types to initialize vectors instead of their size
</span><span class=c1></span><span class=n>vec</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>int_vec</span> <span class=o>=</span> <span class=n>vec_init</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
<span class=kt>int</span> <span class=n>elem</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
<span class=n>vec_push</span><span class=p>(</span><span class=o>&amp;</span><span class=n>int_vec</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>elem</span><span class=p>);</span>
<span class=c1>// The length is not directly accessible but a helper function gets it easily
</span><span class=c1></span><span class=n>vec_len</span><span class=p>(</span><span class=n>int_vec</span><span class=p>);</span>
<span class=c1>// The vector can be indexed directly as it points to the start of the array without the interference of any of its metadata
</span><span class=c1></span><span class=n>int_vec</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</code></pre></td></tr></table>
</div>
</div><p>Due to the simpler and more readable nature of our approach, it was favored over the intuitive one that would make the usage of vectors more of a chore.</p>
<p>After the dynamic array, we needed another data structure that we’ll use countless times throughout the project, a hash table. At first, we tried implementing our own hashmap, however, since this was at the beginning of the project and we didn’t have much experience with C’s advanced features, we couldn’t do it in a way that is generic enough to be usable in arbitrary places. That’s why we changed our goal from developing our own hashmap to finding one that is generic and efficient and using it instead. That’s when we found tidwall&rsquo;s <a href=https://github.com/tidwall/hashmap.c target=_blank rel="noopener noreffer">hashmap.c</a>.</p>
<p>After going through the library, making sure it does everything we need it to, and understanding how it does it, we had a small problem with it; its API was (in our opinion) very unclean. While that would seem like a minor problem that can be ignored, the API’s problems were mainly:
The hashmap treats keys and values as a single object. Thus, having a hashmap for a specific key-value pair would require us to define our own type that combines this pair and defining our own custom hashing and comparison functions so that the hashmap doesn’t knows how to interact with that object.
The hashmap has no concept of destructors. While that wouldn’t be a problem with plain objects that don’t have any references to other data, as soon as a hashmap element has a reference, removing that element from the map will most probably result in a memory leak (unless treated specifically.)</p>
<p>These two problems, while not critical, would put us in a place where it’s too risky to use the hashmap without having them in mind. Luckily, both of those problems could be fixed and the API could be made way better with the help of C preprocessor without sacrificing any of its efficiency or genericness.</p>
<p>Now that the core is able to provide the most basic utilities, it needs to provide a way for modules to communicate by sending notifications when important events occur. For that feature, an event system is needed.</p>
<p>One of the major challenges of having an event system written in C is the fact that events are, by nature, very dependent on polymorphism. For example, there are generic events like: Window Event, Mouse Event, Key Event, ..etc. and more detailed events like: KeyDown Event, MouseMoved Event, ..etc. Another problem is that event dispatches are supposed to work with all events that may have different sizes and thus require a way for the compiler to know what to do with each type. Unfortunately, doing so will make the simple act of defining a new event type verbose enough to be unreadable in the long run.</p>
<p>Luckily, this was found to be a bit more manageable than initially expected. First of all, for the events to be passable through functions, they’d need to have the same size, which is impractical. What would have a constant size is each event’s reference. After that comes the part of actually knowing what kind of event it is as all references look the same. This was fixed by adding an “event type” field in the event that will be the first few bytes at the memory address the event references.</p>
<p>As for supporting some degree of polymorphism, events were split into “Primary” and “Secondary” events. This way, the event type field could simply be made to be a single 32-bit value of which the first 16 bits are the primary type of the event and the other 16 bits are the secondary event which gives more details about the event itself.</p>
<p>Now that events are split into two degrees (Primary and Secondary), it would be nice if secondary events had the same parameters that their parent “Primary” event has without the need to specify those fields manually for each event. While the way to do that would be trivial to find in an object-oriented language, doing so in C was not that obvious, until we noticed one of the lesser known features of the C11 language standard; it’s called “anonymous structs” and it allows structs to have other (anonymous) structs of which they inherit the fields without explicitly exposing the fact that they have that struct inside them.
Now that the structure of the events is finished, the next step is to see how the eventsystem will dispatch said events. The main idea was that there will be a list of events that is filled throughout the frame and then, at a specific stage, all those events will be dispatched to their listeners and then the list will be cleared. An important step was to ensure thread safety in that event list so that modules can dispatch events without needing to rely on a single event-dispatching thread. This was easily done by using a mutex that ensures exclusive access when adding events to that list.</p>
<p>A problem that we didn’t notice unless it started affecting us is that event handlers can dispatch other events. This means that new unhandled events will be added to the list right before it is cleared. This was fixed by building a double-buffered vector; a buffer for reading and a buffer for writing. This way, the two buffers are to be swapped each frame so that the one that was being written to is the one being currently read for event handling while new events are being added to the write buffer.</p>
<p>As for event listeners, they were given some flexibility in what they can listen to. Due to the fact that the event type contains two values (the primary type and the secondary type), the listeners can either choose to listen for a specific secondary type or to listen for a primary type and therefore listen to all the secondary events that have that type in as their primary type.</p>
<p>Next in line is the module manager. The module manager’s main responsibility is to keep track of the modules that are available for the framework to load on demand. This helps when modules need to load other modules without knowing their exact path in the filesystem. The first thing that this module manager does is that it takes a module directory that it scans to identify all the available modules, their names and their categories. After that, whenever a module needs to be loaded, it can be referenced using its name or category. This means that instead of writing</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>ev_module_open</span><span class=p>(</span><span class=s>&#34;./modules/bullet-physics.evmod&#34;</span><span class=p>)</span>
</code></pre></td></tr></table>
</div>
</div><p>this can be written:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>evol_loadmodule</span><span class=p>(</span><span class=s>&#34;physics&#34;</span><span class=p>)</span>
</code></pre></td></tr></table>
</div>
</div><p>while maintaining the intended behaviour.</p>
<p>To allow tunable parameters in the framework and in modules, a configuration file was needed. That is why a configuration loader was created. The configuration loader’s goals were pretty simple: we needed a file to contain some variables that the modules could look up at runtime. As for the format of that configuration file, we settled on Lua since we were already planning on having the scripting engine be made in Lua and thus this would help us reuse some of the utilities we will create for interacting with Lua.</p>
<p>That was a good time for us to start creating our Lua utility functions. We created several functions that, in our opinion, should help us interact with almost any arbitrary Lua file without the need to deal with the low level details of the Lua stack. Those functions were:</p>
<table>
<thead>
<tr>
<th>Function&ndash;</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ev_lua_newState</code></td>
<td>Creates a new Lua VM and loads the standard libraries into it</td>
</tr>
<tr>
<td><code>ev_lua_destroyState</code></td>
<td>Destroys given Lua VM</td>
</tr>
<tr>
<td><code>ev_lua_loadfile</code></td>
<td>Loads a Lua file from the filesystem and pushes it to the top of the given Lua VM’s stack</td>
</tr>
<tr>
<td><code>ev_lua_runloadedfile</code></td>
<td>Executes the file that is on top of the Lua stack (the last file loaded by ev_lua_loadfile)</td>
</tr>
<tr>
<td><code>ev_lua_runfile</code></td>
<td>Loads and executes that contents of a file (equivalent to calling ev_lua_loadfile followed by ev_lua_runloadedfile)</td>
</tr>
<tr>
<td><code>ev_lua_getstring</code></td>
<td>Takes a Lua variable name, finds it in the Lua VM, checks to see if it is a string, then returns it.</td>
</tr>
<tr>
<td><code>ev_lua_getint</code></td>
<td>Takes a Lua variable name, finds it in the Lua VM, checks to see if it is an integer, then returns it.</td>
</tr>
<tr>
<td><code>ev_lua_getdouble</code></td>
<td>Takes a Lua variable name, finds it in the Lua VM, checks to see if it is a double precision floating point number, then returns it.</td>
</tr>
<tr>
<td><code>ev_lua_runstring</code></td>
<td>Takes a Lua code string and executes it</td>
</tr>
<tr>
<td><code>ev_lua_callfn</code></td>
<td>Takes a Lua function name, its parameters, and variables in which the return values should be written, finds that function and calls it.</td>
</tr>
</tbody>
</table>
<p>One of the most important utilities needed by any software is the ability to use multiple threads to make use of the concurrency that is built into modern CPUs. At first, it seemed as if adding thread utilities would be a breeze since the C11 language standard already provided concurrency primitives in the standard libraries. However, due to the fact that C11 had it as an optional feature, the Visual Studio compiler (MSVC) didn’t feel the need to provide it and only provided the primitives that are already exposed through the Windows API.</p>
<p>Luckily, the usage of Windows API concurrency primitives was quite similar to their Unix counterparts and thus wrapping them into the same API was, despite being a chore, pretty trivial. For the wrapping style, we decided to use the pthreads API that is already provided in Unix systems as a reference. This way, we only needed to wrap the Windows API without needing to make any changes on non-Windows systems.</p>
<p>Now that we had cross-platform concurrency primitives, we needed a way to remove the overhead of creating those primitives for systems that will consistently need the creation of those primitives periodically. That is why we implemented a threadpool. A threadpool is quite simple in concept; it is simply a list of threads that are already initialized and are waiting to be used. Work is submitted to that list by simply adding it to a list of job requests that threads check to see if there is anything for them to do. While stopping here would be quite reasonable, having the threads regularly check that work list would mean wasting a lot of the CPU time doing nothing but checking a list that would probably have nothing in it most of the time. That’s why we added signals to the mix, by making the threads wait on signals and having those signals be dispatched whenever a new job is added to the job list, threads are put into a sleep state and don’t take any CPU time when there is no work to be done.</p>
<p>The fact that we’re using C meant that we had to deal with one of its more daunting problems; the fact that C’s strings are extremely unsafe. To deal with that, we had to develop our very own safe string library. In that library we used the experience gathered throughout all the previous steps to try making a string library that is not difficult to use. We had a few goals that we needed to meet so that we could consider this library a success:
The library’s strings should be usable by functions that expect normal C strings.
A string’s length should be cached as getting a string’s length is a common operations
Strings should not need to be duplicated or moved when they are needed for simple operations
The first two objectives looked similar to those of the vector type that we already did. That’s when we knew that our string will basically be a specialization of the vector made only for the characters. This means that we’ll have the important metadata stored before the string without the user ever needing to deal with it directly. The first requirement, though, meant that we wouldn’t be able to get rid of the null terminator and that we’d need to keep it at the end of every string so that existing string functions can work with our strings. We ended up with the following API:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>evstring_new</code></td>
<td>Creates an evstring from a given C string</td>
</tr>
<tr>
<td><code>evstring_clone</code></td>
<td>Creates an evstring from a given existing evstring</td>
</tr>
<tr>
<td><code>evstring_free</code></td>
<td>Destroys the given evstring</td>
</tr>
<tr>
<td><code>evstring_len</code></td>
<td>Returns the length of the given evstring</td>
</tr>
<tr>
<td><code>evstring_setlen</code></td>
<td>Sets the length of the given evstring to a given value</td>
</tr>
<tr>
<td><code>evstring_cmp</code></td>
<td>Checks the equality of two strings</td>
</tr>
<tr>
<td><code>evstring_pushchar</code></td>
<td>Appends a given character to the given evstring (dynamically resizing it as needed)</td>
</tr>
<tr>
<td><code>evstring_pushstr</code></td>
<td>Appends a given string to the given evstring (dynamically resizing it as needed)</td>
</tr>
<tr>
<td><code>evstring_pushfmt</code></td>
<td>Appends a new string denoted by a given format string and several values to the end of the given evstring (dynamically resizing it as needed)</td>
</tr>
<tr>
<td><code>evstring_getspace</code></td>
<td>Returns the allocated space at the end of the given evstring that contains no data. (Size of data that can be pushed without the need for a reallocation)</td>
</tr>
<tr>
<td><code>evstring_addspace</code></td>
<td>Adds more space to the given evstring so that more data can be pushed without needing reallocation.</td>
</tr>
<tr>
<td><code>evstring_clear</code></td>
<td>Clears the data that’s inside the given evstring and sets its length to zero.</td>
</tr>
<tr>
<td><code>evstring_newfmt</code></td>
<td>Creates a new evstring from the given format string and the following variables that contain data referenced in the format string.</td>
</tr>
<tr>
<td><code>evstring_findfirst</code></td>
<td>Returns the first occurrence of a given query string inside the given evstring</td>
</tr>
<tr>
<td><code>evstring_replacefirst</code></td>
<td>Replaces the first occurrence of a given query string inside the given evstring with the given replacement string (dynamically resizing it as needed)</td>
</tr>
<tr>
<td><code>evstring_findfirst_ch</code></td>
<td>Finds the index of the first occurrence of a character inside the given evstring</td>
</tr>
<tr>
<td><code>evstring_findlast_ch</code></td>
<td>Finds the index of the last occurrence of a character inside the given evstring</td>
</tr>
</tbody>
</table>
<p>While the already implemented functions already provide a full set of utilities that can deal with almost all the operations that we might need to do with a string, it still doesn’t fix the problem of needing to copy strings for a lot of operations that don’t require such an inefficient operation (like slicing the string). That’s why we came up with the idea of a string reference. A string reference contains exactly three values: a reference to the evstring it’s referencing, the span of the reference, the offset of the reference inside the evstring. This way, a lot of string duplications could be prevented. The following functions were added to the evstring API:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>evstring_ref</code></td>
<td>Creates an evstring reference from the given evstring</td>
</tr>
<tr>
<td><code>evstring_refclone</code></td>
<td>Creates an evstring from a given evstring reference.</td>
</tr>
<tr>
<td><code>evstring_slice</code></td>
<td>Creates an evstring reference that denotes a slice of the given evstring.</td>
</tr>
<tr>
<td><code>evstring_refpush</code></td>
<td>Appends the contents of a given evstring reference to the given evstring (dynamically resizing it as needed)</td>
</tr>
</tbody>
</table>
<p>Since we already knew that we’ll eventually have our scene format and project configuration be in JSON, we decided early on to write our own JSON parser that makes use of our evstring so that it can reduce its memory footprint substantially. We started by writing a JSON tokenizer; the idea was simple: iterate through the JSON file, identify tokens, add them to a token list along with their types. This token list benefited heavily from the evstring references as token data was merely a string reference that points to the actual data that is in the original JSON string.</p>
<p>Now that we have all the tokens ready for interpretation, we start iterating through those tokens and adding them to a hashmap that has the path to each JSON value as the key to ease the process of retrieving the values from it later. This meant that for a simple JSON query, we could write the following:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>evjs_get</span><span class=p>(</span><span class=n>json_context</span><span class=p>,</span> <span class=s>&#34;application.version.major&#34;</span><span class=p>)</span>
<span class=c1>// or
</span><span class=c1></span><span class=n>evjs_get</span><span class=p>(</span><span class=n>json_context</span><span class=p>,</span> <span class=s>&#34;scenes[2].name&#34;</span><span class=p>)</span>
</code></pre></td></tr></table>
</div>
</div><p>Now that a lot of features are available for modules to benefit from, we needed a way to automate some of the common operations for modules, like:
Creation and exposing namespaces
Definition and loading configuration variables from the configuration file
Definition and exposing events that other modules can use</p>
<p>For that, several files were standardized for a module and each of those files was created for the purpose of containing a single set of operations. For example, there was the “evmod.configvars” file; this file’s main purpose was to define configuration variables that the module was expecting from the configuration file along with their types and default values. The file’s format was as follows:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// Window Title
</span><span class=c1></span><span class=n>EV_CONFIG_VAR</span><span class=p>(</span><span class=n>window_title</span><span class=p>,</span> <span class=n>STRING</span><span class=p>,</span> <span class=s>&#34;Default Title&#34;</span><span class=p>)</span>
<span class=c1>// Physics Visualization flag
</span><span class=c1></span><span class=n>EV_CONFIG_VAR</span><span class=p>(</span><span class=n>visualize_physics</span><span class=p>,</span> <span class=n>U8</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</code></pre></td></tr></table>
</div>
</div><p>This way, whenever one of those configuration variables is added to the configuration file, this module will be able to access it. Otherwise, it will simply use the default value that it specified. The fact that the configuration variable is defined in a separate file and through the use of preprocessor macros, the loading of the configuration variable was automated so that the value is automatically loaded whenever the module is initialized. This way, the module can easily start using the configuration variable as if it was an already defined global variable without ever needing to load it explicitly from the configuration loader.</p>
<p>The same goes for another file called “evmod.events”. The purpose of this file is to serve as the place in which a module’s events are defined. The file’s structures looks something like:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=c1>// Primary Events
</span><span class=c1></span><span class=n>PRIMARY</span><span class=p>(</span><span class=n>MouseEvent</span><span class=p>,</span> <span class=p>{</span> <span class=n>GenericIOEvent</span><span class=p>;</span> <span class=p>})</span>
<span class=n>PRIMARY</span><span class=p>(</span><span class=n>WindowEvent</span><span class=p>,</span> <span class=p>{</span><span class=n>GenericIOEvent</span><span class=p>;</span> <span class=p>})</span>

<span class=c1>// Secondary Window Events
</span><span class=c1></span><span class=n>SECONDARY</span><span class=p>(</span><span class=n>WindowEvent</span><span class=p>,</span> <span class=n>WindowResizedEvent</span><span class=p>,</span> <span class=p>{</span><span class=n>U32</span> <span class=n>newWidth</span><span class=p>;</span> <span class=n>U32</span> <span class=n>newHeight</span><span class=p>;</span> <span class=p>})</span>

<span class=c1>// Secondary Mouse Events
</span><span class=c1></span><span class=n>SECONDARY</span><span class=p>(</span><span class=n>MouseEvent</span><span class=p>,</span> <span class=n>MouseMovedEvent</span><span class=p>,</span> <span class=p>{</span> <span class=n>MousePosition</span> <span class=n>position</span><span class=p>;</span> <span class=p>})</span>
<span class=n>SECONDARY</span><span class=p>(</span><span class=n>MouseEvent</span><span class=p>,</span> <span class=n>MouseButtonPressedEvent</span><span class=p>,</span> <span class=p>{</span> <span class=n>GenericMouseButtonEvent</span><span class=p>;</span> <span class=p>})</span>
</code></pre></td></tr></table>
</div>
</div><p>There are two other files that are called “evmod.types” and “evmod.namespaces” that do the same to expose module-specific types and namespaces that the module exposes.</p>
</div><div class=post-footer id=post-footer>
<div class=post-info><div class=post-info-tag><span><a href=/tags/game-engine/>Game Engine</a>
</span></div><div class=post-info-line><div class=post-info-mod>
<span>Updated on 2021-07-31</span>
</div><div class=post-info-mod></div>
</div><div class=post-info-share>
<span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://mo7sen.github.io/projects/evol/modules/core/ data-title=evol-core data-via=mo7sener data-hashtags="Game Engine"><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://mo7sen.github.io/projects/evol/modules/core/ data-hashtag="Game Engine"><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="Share on Reddit" data-sharer=reddit data-url=https://mo7sen.github.io/projects/evol/modules/core/><i class="fab fa-reddit fa-fw"></i></a></span>
</div></div><div class=post-nav><a href=/projects/evol/modules/physics/ class=prev rel=prev title=evol-physics><i class="fas fa-angle-left fa-fw"></i>Previous Post</a>
<a href=/projects/evol/modules/asset-manager/ class=next rel=next title=evol-assetmanager>Next Post<i class="fas fa-angle-right fa-fw"></i></a></div></div>
</div></article></div>
</main>
<footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://mo7sen.github.io/about>Robear Selwans</a></span></div>
</div>
</footer>
</div>
<div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top">
<i class="fas fa-chevron-up fa-fw"></i>
</a></div><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script src=/lib/lazysizes/lazysizes.min.js></script><script src=/lib/clipboard/clipboard.min.js></script><script src=/lib/sharer/sharer.min.js></script><script>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:10},comment:{}}</script><script src=/js/theme.min.js></script></body></html>