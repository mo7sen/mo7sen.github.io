<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Project - Category - Robear Selwans' Portfolio</title><link>https://mo7sen.github.io/categories/project/</link><description>Project - Category - Robear Selwans' Portfolio</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>robear.selwans@outlook.com (Robear Selwans)</managingEditor><webMaster>robear.selwans@outlook.com (Robear Selwans)</webMaster><lastBuildDate>Sat, 31 Jul 2021 13:25:24 +0000</lastBuildDate><atom:link href="https://mo7sen.github.io/categories/project/" rel="self" type="application/rss+xml"/><item><title>RusTracer</title><link>https://mo7sen.github.io/projects/rustracer/</link><pubDate>Sat, 31 Jul 2021 13:25:24 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/rustracer/</guid><description>In an effort to learn about ray tracing, I decided to follow ssloy’s tinyraytracer tutorial which is, in my opinion, a very gentle introduction into the world of raytracing. Despite the tutorial using C++, I decided to use Rust for no reason except that I hadn’t written any Rust code in a while and felt a bit rusty (pun intended).
Another thing that I did differently from the tutorial is that I rendered to an SDL window instead of rendering to an image.</description></item><item><title>RustyNinja</title><link>https://mo7sen.github.io/projects/rustyninja/</link><pubDate>Sat, 31 Jul 2021 13:25:24 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/rustyninja/</guid><description>It started with me finding out that RDJ2019 (Game showcase event) was around the corner and deciding that I wanted to submit an entry for a game that I’d like to play. So I started thinking about a game idea until I remembered this clip. I liked the idea of a ninja jumping on missiles while simultaneously destroying them, and that’s what I decided to make.
So the idea was as follows: you’re a ninja in a peaceful village, an army is attacking the village to get rid of its residents and control its resources, you start attacking the missiles that are shot at the village to make sure that none of them reach their target.</description></item><item><title>evol</title><link>https://mo7sen.github.io/projects/evol/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol/</guid><description>&lt;p>A game engine built using C.&lt;/p></description></item><item><title>evol Architecture</title><link>https://mo7sen.github.io/projects/evol-architecture/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol-architecture/</guid><description>Overview Any software that is being designed needs to adhere to a specific architecture. Having an explicit architecture allows the design process to be much smoother as architectures come with their own set of rules that can increase consistency across the entire software. A game engine is no different; in fact, as the game engine is a much bigger software than most, it sometimes needs to have multiple architectures with some subsystems having their own ones.</description></item><item><title>evol-assetmanager</title><link>https://mo7sen.github.io/projects/evol-assetmanager/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol-assetmanager/</guid><description>The asset managers try to provide some features that make the workflow of adding/using assets less painful. While there is no fancy features like asynchronous loading or callbacks, the base foundation of the asset manager is quite flexible and allows the addition of such features in the future.
Mounts Ok, so it&amp;rsquo;s probably not the best idea to start this off with a QoL feature, but it&amp;rsquo;s too fun to leave for later.</description></item><item><title>evol-core</title><link>https://mo7sen.github.io/projects/evol-core/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol-core/</guid><description>First of all, comes the core. The core was implemented in a way that ensures that all core functionalities are provided to the modules without the need for complex dependencies. The first thing that needed to be done was to make the modules loadable/unloadable at runtime. While multiple approaches were tried out at the beginning, the most stable one was the use of dynamically loaded libraries (DLLs). The main advantage of using DLLs is the fact that the load/unload operation is handled primarily by the operating system.</description></item><item><title>evol-game</title><link>https://mo7sen.github.io/projects/evol-game/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol-game/</guid><description>The game module is where most of the fun actually happens; the game module attempts to use the other modules to make the program behave as a game engine. Through the combination of the world module, the input module, the physics module, the script module, the asset module and the rendering module, the game module manages to connect all these modules together to make an actual game that runs.
First of all is the scene representation; in the game module, a scene is an isolated component that cannot interact with other scenes.</description></item><item><title>evol-renderer</title><link>https://mo7sen.github.io/projects/evol-renderer/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol-renderer/</guid><description> Under construction</description></item><item><title>evol-scripting</title><link>https://mo7sen.github.io/projects/evol-scripting/</link><pubDate>Sat, 31 Jul 2021 13:25:00 +0000</pubDate><author>robear.selwans@outlook.com (Robear Selwans)</author><guid>https://mo7sen.github.io/projects/evol-scripting/</guid><description>The scripting module was written in a way that makes it as flexible and as accessible as possible for all modules that might need it. First of all, “Game World” systems were created to allow the running of per-frame update functions that could be written in scripts. This meant that systems will only need to run for entities that have those script functions without needing to iterate over all entities to check.</description></item></channel></rss>